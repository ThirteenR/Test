BufferedReader:
   实例化阶段传人一个Reader实例，同时创建一个buffer byte数组；
   调用readLine方法：
     开始轮询缓存，
       判断字符轮询结束的位置是否超出或者等于缓存数据的长度；
       如果超出或者相等，则对缓存进行重新装载数据；
       装载数据后判断字符轮询结束的位置是否超出或者等于缓存数据的长度；
       如果超出长度或者和缓存的数据长度相同，则stream中的数据已经被加载完，缓存中为装载出数据，返回null；
       如果指针未超出缓存数据的长度，此时
         创建一个eol终点标记的变量，
         缓存当前字符的变量c，
         轮询标记指针变量i，
       如果允许省略换行且当前字符为换行符，则将nextChar（字符轮询结束的下一个位置）自加1；
       接着开始轮询字符，以缓存数据长度为最终边界，逐个字符轮询，
       if ((c == '\n') || (c == '\r'))遇到换行符，将eol终点标记为true，break跳出当前的字符轮询；
       将nextChar（字符轮询结束的位置）赋值给startChar（字符轮询开始的位置）；
       将nextChar（字符轮询结束的位置）赋值为i（当前读取字符的位置）；
       从startChar开始从缓存中创建一个长度为i-startChar长度的字符串（此次轮询过的字符串）；
       如果整个当前缓存的数据轮询完毕最后不是换行符，则创建一个StringBuffer，将剩余缓存的字符串append进StringBuffer中，等待下一个缓存轮询到换行将其补全；
     缓存轮询完成继续获取下一个缓存，轮询字符，直到stream中的数据被获取完，没有数据可以装载入缓存，此时轮询字符nextChar的数值以及缓存数据长度nChar的数值相等，
     检查StringBuffer中是否还有前一个缓存加载的字符串，如果有就toString并且返回，如果没有就返回null；



